\chapter*{Appendix}

\section*{Socialist millionaires with EdDSA}

\lstset{caption={Socialist Millionairs Proof implemented with EdDSA.},label=lst:SMEdDSA}
\begin{lstlisting}
from ecpy.curves     import Curve,Point
from ecpy.keys       import ECPublicKey, ECPrivateKey
from ecpy.eddsa      import EDDSA
from ecpy.formatters import decode_sig, encode_sig
import time
start_time = time.time()

C = Curve.get_curve('Ed25519')
G = C.generator
q = C.order

import random
import hashlib

x = random.randint(1,q-1)
y = x

# Alice 
# picks two random numbers: a2 and a3 

a2 = random.randint(1,q-1)
a3 = random.randint(1,q-1)

# computes G2a = a2 * G and G3a = a3 * G 

G2a = C.mul_point(a2, G) 
G3a = C.mul_point(a3, G)

# encodes G2a and G3a

eG2a = C.encode_point(G2a) 
eG3a = C.encode_point(G3a)

# sends eG2a and eG3a to Bob

# Bob 
# picks two random numbers: b2 and b3 

b2 = random.randint(1,q-1)
b3 = random.randint(1,q-1)

# computes G2b = b2 * G and G3b = b3 * G 

G2b = C.mul_point(b2, G)
G3b = C.mul_point(b3, G)

# encodes G2a and G3a

eG2b = C.encode_point(G2b) 
eG3b = C.encode_point(G3b)

# computes G2B = b2 * G2a and G3B = b3 * G3a 

G2B = C.mul_point(b2, G2a) 
G3B = C.mul_point(b3, G3a)

# encodes G2B and G3B

eG2B = C.encode_point(G2B) 
eG3B = C.encode_point(G3B)

# picks random number r 
r = random.randint(1,q-1)

# computes Pb = r * G3B and Qb = r * G + y * G2B

Pb = C.mul_point(r, G3B)

q1b = C.mul_point(r, G)
q2b = C.mul_point(y, G2B)
Qb = C.add_point(q1b, q2b)

# encodes Pb and Qb

ePb = C.encode_point(Pb) 
eQb = C.encode_point(Qb)

# sends eG2b, eG3b, ePb and eQb to Alice
# Alice 

# computes G2A = a2 * G2b and G3A = a3 * G3b

G2A = C.mul_point(a2, G2b) 
G3A = C.mul_point(a3, G3b)

# encodes G2B and G3B

eG2A = C.encode_point(G2A) 
eG3A = C.encode_point(G3A)

# picks random number s 
s = random.randint(1,q-1)

# computes Pa = s * G3A and Qa = s * G + x * G2A

Pa = C.mul_point(s, G3A)

q1a = C.mul_point(s, G)
q2a = C.mul_point(x, G2A)
Qa = C.add_point(q1a, q2a)

# encodes Pa and Qa

ePa = C.encode_point(Pa) 
eQa = C.encode_point(Qa)

# computes Ra = a3 * (Qa - Qb)

Qab = C.sub_point(Qa, Qb)
Ra = C.mul_point(a3, Qab) 

# encodes Ra
eRa = C.encode_point(Ra) 

# sends ePa, eQa, eRa to Bob

# Bob 

# computes Rb = b3 * (Qa - Qb)

Qba = C.sub_point(Qa, Qb)
Rb = C.mul_point(b3, Qba)

# encodes Rb
eRb = C.encode_point(Rb)

# computes Rba = b3 * Ra

Rba = C.mul_point(b3, Ra)
Pba = C.sub_point(Pa, Pb)

# encodes Pba and Rba

ePba = C.encode_point(Pba) 
eRba = C.encode_point(Rba)

# checks whether Rab == Pa - Pb 

if (eRba == ePba):
    print("Yolo")
else:
    print("Rba = " + str(eRba))
    print("Pba = " + str(ePba))
    
# sends Rb to Alice

# Alice 
# computes Rab = a3 * Rb

Rab = C.mul_point(a3, Rb)
Pab = C.sub_point(Pa, Pb)

# encodes Pab and Rab

ePab = C.encode_point(Pab) 
eRab = C.encode_point(Rab)

# checks whether Rab == Pa - Pb 

if (eRab == ePab):
    print("Yolo")
else:
    print("Rab = " + str(eRab))
    print("Pab = " + str(ePab))
    
print("--- %s seconds ---" % (time.time() - start_time))
\end{lstlisting}

\section*{Improved OAuth 2.0 proof with EdDSA}

\lstset{caption={Alice wants to prove their identity to Bob without revealing their pseudonym. The proof has been implemented with EdDSA.},label=lst:IdEdDSA}
\begin{lstlisting}
start_time = time.time()

def sha512(s):
    return hashlib.sha512(s).digest()
    
# Bob knows Q = x * G
# Given a curve with generator G and its order q Alice can prove to Bob
# she knows 0 < x < n such that Q = x * G by: 

Q = x * G
r = random.randint(1,q-1) 
W = r * G
eW = C.encode_point(W)
ec = sha512(eW)
c = int.from_bytes(ec,'big')
d = r - x*c%q 

# presenting (c, d) to Bob Bob verifies the proof by checking:
pA = C.mul_point(d,G)
pB = C.mul_point(c, Q)

pnt = C.add_point(pA, pB)
epnt = sha512(C.encode_point(pnt))
if  (ec == epnt):
    print("Yolo")
else:
    print("Nope")
    
print("--- %s seconds ---" % (time.time() - start_time))

\end{lstlisting}